# Лабораторная работа: Измерение расстояний между UWB-трекерами и фильтрация данных

## Описание

В данной лабораторной работе мы исследуем принципы измерения расстояния между двумя UWB (Ultra-Wideband) трекерами: **tag** и **anchor**, а также применяем одномерный расширенный фильтр Калмана (EKF) для фильтрации измеренных данных и восстановления более точных координат и скоростей.

## Что такое tag и anchor?

UWB-трекеры — это устройства, способные точно измерять расстояние друг до друга с помощью импульсных радиосигналов.

* **Anchor** — это стационарное устройство, к которому привязываются измерения. Оно инициирует опрос, отправляя сигнал tag'у, и по времени ответа оценивает расстояние.
* **Tag** — это подвижное устройство, которое принимает сигнал от anchor'а и отвечает на него. На основе времени между отправкой и приёмом сигнала, anchor рассчитывает расстояние до tag.


Измерения происходят с использованием протокола Time-of-Flight (ToF), обеспечивающего точность на уровне нескольких сантиметров. Каждое измерение представляет собой задержку между отправкой сигнала и его приёмом с учётом времени на обработку. Эта информация преобразуется в расстояние с учётом скорости радиосигнала (практически равной скорости света).

![](data/Communication-between-UWB-Anchor-and-Tag.png)


---

## TODO Описание что за трекеры и какую ось мы используем

---

## Подключение оборудования

1. Подключаем два UWB трекера к компьютеру по USB. На них уже загружены прошивки.
2. Проверяем список подключенных устройств:

   ```bash
   ls /dev/tty.usbmodem*
   ```

   Вы увидите, например:

   ```
   /dev/tty.usbmodem0007601893361
   /dev/tty.usbmodem0007601888971
   ```
3. Запускаем скрипт `tag.py` на одном из устройств:

   ```bash
   mpremote connect /dev/tty.usbmodem0007601893361 run tag.py
   ```
4. Запускаем скрипт `anchor.py` на другом устройстве, при этом сохраняем вывод в лог-файл:

   ```bash
   mpremote connect /dev/tty.usbmodem0007601888971 run anchor.py > data/log.txt
   ```
5. Имитируем движение tag по произвольной траектории — anchor будет записывать измерения расстояний между устройствами в `data/log.txt` (можно указать другое).

---

## Предобработка данных

Терминальные логи из `log.txt` необходимо преобразовать в структурированный формат (JSON или список словарей) для дальнейшей обработки:

```bash
python3 src/convert_logs.py <путь_к_входному_txt_файлу> <путь_к_выходному_json_файлу>
```

Результатом будет файл с измерениями, который может быть передан на вход фильтрации.

---

## Оценка точности измерений

Перед запуском фильтра полезно провести серию статических измерений — расположить устройства на фиксированном расстоянии и записать несколько десятков измерений.

Это позволяет:

•	Оценить статистическую погрешность измерений;

•	Вычислить дисперсию измерений, которую затем можно использовать как параметр R фильтра Калмана.

Формула для оценки дисперсии:
$$
\sigma^2 = \frac{1}{N} \sum_{i=1}^N (x_i - \bar{x})^2
$$
где $x_i$ — отдельное измерение, $\bar{x}$ — среднее значение.

```bash
python3 src/estimate_variance.py <полный_путь_к_файлу>
```

Выведет важные параметры измерения.

(Для корректной работы данные так же нужно данные из логов сконвертировать в json-файл)

---

## Фильтрация данных

Фильтрация производится с использованием одномерного расширенного фильтра Калмана (EKF), который восстанавливает положение и скорость tag по шумным измерениям расстояний.

### Как работает фильтр?

Фильтр Калмана — это рекурсивный алгоритм, который обновляет оценки состояния системы (в нашем случае — координаты и скорости tag) на основе модели движения и входящих измерений.

Расширенный фильтр Калмана учитывает нелинейную зависимость между расстоянием и положением, аппроксимируя её с помощью якобианов.

На каждом шаге фильтр выполняет:

1. **Прогноз** нового состояния на основе предыдущей скорости и положения
2. **Коррекцию** на основе нового измерения расстояния

Таким образом, он эффективно сглаживает шум и восстанавливает траекторию движения.

### Запуск фильтра:

```bash
python3 src/EKF_1D/main.py <путь_к_входному_json_файлу> <путь_к_выходному_json_файлу> <путь_к_png_графику> 
```

При запуске необходимо ввести:

* **Дисперсию измерений** (характеризует точность измерения расстояния UWB-сигналом) — было измерено.
* **Дисперсию движения** (отражает степень изменчивости движения tag) — можно оценить эмпирически: если tag двигается с постоянной скоростью, можно взять небольшое значение (например, 0.1). Если движения резкие и хаотичные — увеличить (например, до 2.0).
* **Начальное расстояние** между tag и anchor
* **Статистическая погрешность** — значение вычисленное при измерении с неподвижными датчиками.

### Как влияют параметры фильтра?

* **Дисперсия измерений (R)** — при больших значениях фильтр меньше доверяет входящим данным, и сглаживает траекторию сильнее. При малых — траектория ближе к "сырым" данным.
* **Дисперсия движения (Q)** — характеризует доверие к модели движения. При больших значениях фильтр допускает более резкие изменения скорости. При малых — предполагает движение с постоянной скоростью.

Экспериментируя с этими параметрами, можно добиться наилучшего приближения к реальной траектории.

---

## Интерпретация результатов

После работы фильтра вы получите график с:

* Измеренными расстояниями (с шумами)
* Отфильтрованными координатами и скоростью tag

Анализируя графики, можно:

* Оценить точность измерений
* Визуализировать реальную траекторию движения tag
* Понять, как параметры фильтра влияют на результат


1. Верно подобранная R
   ![](plt1.png)

2. Поведение при слишком маленькой R
   ![](plt3.png)

3. Поведение при завышенной R
   ![](plt2.png)

